---
title: "MAG-level metatranscriptomics analysis"
author: "Shaman Narayanasamy"
editor: source
fig-cap-location: bottom
format:
  pdf: default
  html: default
execute:
  echo: false 
  warning: false
  message: false
---
# Description
This document was generated directly from a quarto markdown file that contains the code for the analysis. To view the code, please visit the membrane cleaning github repository or request it from the author of this file.
```{r loading libraries, warning=F, message = F}
# tidytranscriptomics-related packages
library(tidybulk)
library(tidySummarizedExperiment) # we'll load this below to show what it can do
library(sva) # Must be loaded AFTER tidySummarizedExperiment as there is a clash in one of the dependency packages
library(DESeq2)

# tidyverse-friendly packages
library(tidyverse)
library(googlesheets4)
library(metap)
library(patchwork)
library(plotly)
library(ggrepel)
library(GGally)
library(tidyHeatmap)
```
## Data 
This analysis focuses on the MAG "TI2_MAGScoT_cleanbin_000096" which represents the Geobacter genus. We hereafter refer to this as "Geobacter MAG". For this analysis, we require the following information:
- Raw counts of all features/transcripts
- List and annotation of all transcripts that belong to Geobacter
- Sample information table

```{r load_MAG_data}
bakta2MAG_path <- '/scratch/users/snarayanasamy/membrane_cleaning/output/metatranscriptomics/quantification/bin2bakta_id_mappings.tsv'

bakta2MAG <- sprintf('ssh iris "cat %s"', bakta2MAG_path ) %>%   
  pipe() %>%  
  read_tsv(col_names = c("MAG_ID", "Bakta_ID"))
```

```{r load_sample_information}
sample_info <- read_tsv('/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/mt_sample_info.txt', comment = "#") %>% 
  mutate(sample_ID = paste(sample, lane, sep = '_'),
         lane = as.numeric(str_extract(lane, "\\d+"))) %>% 
  select(sample_ID, everything(), -sample, -R1, -R2) 

annotation_folder <- '/scratch/users/snarayanasamy/membrane_cleaning/output/annotation/all/bakta/'

MAG_annotation <- 
  sprintf('ssh iris "cat %s"', paste(annotation_folder, "*", paste0("*", ".tsv"), sep = '/')) %>%  
  pipe() %>%   
  read_tsv(comment = "#", col_names = F) %>% 
  select(feature = X6, type = X2, gene_symbol = X7, gene_function = X8, gene_IDs = X9 )
```

```{r select_features_from_MAG}
Bakta_IDs_of_interest <- filter(bakta2MAG, MAG_ID %in% c(MAGs_of_interest)) %>% pull(Bakta_ID)

counts <- 
  read_tsv("/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/metatranscriptomics_counts.tsv")

counts <- 
  counts %>%  
  filter(Bakta_ID %in% Bakta_IDs_of_interest) %>% 
  pivot_longer(
    cols = sample_info %>% pull(sample_ID),
    names_to = "sample_ID", 
    values_to = "counts") %>% 
  left_join(sample_info, by = "sample_ID") %>% 
  separate(sample_ID, into = c("SampleName"), sep = '_', remove = F, extra = "drop") %>% 
  mutate(SampleName = str_remove(SampleName, "\\d+")) %>% 
  select(feature = Name, sample = sample_ID, counts, SampleName, condition, phase, replicate, lane, Run = sample_ID, avgLength = EffectiveLength) %>% 
  as_SummarizedExperiment(.sample = sample,
                          .transcript = feature,
                          .abundance = counts)
```
## Scaling and normalisation
Scaling  and/or normalisation is typically carried out by individual differential expression (DE) analysis methods. However, this is not a standard transcriptomics analysis, rather an analysis of a pseudo-isolate (i.e. MAG) isolate analysis using metatranscrtipcomics data, hence we perform several strategies for normalising the data. These inlude:
1. ComBat-seq normalisation based on batch effect correction
2. Housekeeping gene (HKG) -based scaling
3. Combination of all the above
```{r create_DESeq2_object}
dds <- DESeq2::DESeqDataSet(counts %>% as_tibble() %>% mutate(counts = as.integer(counts + 1),
                                                              condition = as.factor(condition),
                                                              phase = as.factor(phase),
                                                              replicate = as.factor(replicate),
                                                              lane = as.factor(lane)
                                                              ) %>% 
      as_SummarizedExperiment(.abundance = counts, .sample = sample, .transcript = feature),   
      design = ~ condition*phase + replicate + lane)
```

```{r compbat_seq_scaling, output = F}
combat_counts <- 
  ComBat_seq(counts(dds), 
             batch = colnames(dds) %>% as_tibble() %>% rename(sample = value) %>% left_join(sample_info, by = c("sample" = "sample_ID")) %>% pull(replicate),
             group = colnames(dds) %>% as_tibble() %>% rename(sample = value) %>% left_join(sample_info, by = c("sample" = "sample_ID")) %>% pull(condition)
             ) %>% 
  as_tibble(rownames = "feature") %>% 
  pivot_longer(cols = sample_info$sample_ID, names_to = "sample", values_to = "combat_counts") %>% 
  right_join(counts %>% as_tibble(), by = c("feature", "sample")) %>% 
  dplyr::select(-counts) %>% 
  rename(counts = combat_counts) %>% 
  as_SummarizedExperiment(.abundance = counts,
                          .sample = sample,
                          .transcript = feature)
```
### Housekeeping gene (HKG) evaluation
The genes in @tbl-hkg_list are considered housekeeping genes and are evaluated for their suitability to be used for scaling the data.
```{r list_housekeeping_genes}
housekeeping_genes <- c("gyrA",
                        "gyrB",
                        "recA",
                        "rho",
                        "ffh",
                        "fusA",
                        "dnaK",
                        "groEL",
                        "groES") 
```

```{r}
#| label: tbl-hkg_list
#| tbl-cap: "List of housekeeping genes."
housekeeping_genes %>% as_tibble() %>% rename(`housekeeping_gene_symbol` = value) %>% knitr::kable()
```
```{r show_hkg_information}
#| label: tbl-hkg_genes_count
MAG_annotation %>% 
  filter(gene_symbol %in% housekeeping_genes) %>% 
  left_join(counts %>% as_tibble(), by = "feature") %>% 
  group_by(feature, sample) %>% 
  summarize(
    avg_count = mean(counts, na.rm = TRUE)
  ) %>%
  ungroup() %>% 
  group_by(feature) %>% 
    summarize(
    mean_count = mean(avg_count, na.rm = TRUE),
    sd_count = sd(avg_count, na.rm = TRUE),
    cv = sd_count / mean_count
  ) %>%
  arrange(cv) %>% 
  left_join(MAG_annotation) %>% 
  select(gene_symbol, mean = mean_count, sd = sd_count, cv, `function` = gene_function) %>% 
  knitr::kable(digits = 2, caption = "List of genes that could be used for houskeeping gene based normalisation. The mean and standard deviation (sd) are based on the raw read counts and the coefficient of variation (cv) represents the variation of these genes accross all samples and replicates. Lower cv represents less variation. Genes with the least variation should used as references in housekeeping gene normalisation.")
```

```{r visualise_hkg_condition}
#| fig-cap: "Expression of housekeeping genes within conditions based on raw counts."
#| label: fig-hkg_expression_conditions

MAG_annotation %>% 
  filter(gene_symbol %in% housekeeping_genes) %>% 
  left_join(counts %>% as_tibble(), by = "feature") %>% 
  # make faceted stripchart
  ggplot(aes(x = condition, y = counts + 1, fill = condition, group = condition)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~gene_symbol) +
  scale_y_log10() +
  theme_minimal()
```
```{r visualise_hkg_replicate}
#| fig-cap: "Expression of housekeeping genes within replicates based on raw counts."
#| label: fig-hkg_expression_replicates
MAG_annotation %>% 
  filter(gene_symbol %in% housekeeping_genes) %>% 
  left_join(counts %>% as_tibble(), by = "feature") %>% 
  mutate(replicate = as.character(replicate)) %>% 
  # make faceted stripchart
  ggplot(aes(x = replicate, y = counts + 1, fill = replicate, group = replicate)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~gene_symbol) +
  scale_y_log10() +
  theme_minimal()
```
```{r hkg_replicate_tables, message=F, warning=F, eval = F}
housekeeping_replicates <- list()
for (replicate_id in unique(sample_info$replicate)) {
 
   housekeeping_replicates[[replicate_id]] <-  
     MAG_annotation %>%  
     filter(gene_symbol %in% housekeeping_genes) %>% 
     left_join(counts %>% as_tibble(), by = "feature") %>% 
     filter(replicate == replicate_id) %>% 
     group_by(feature, sample) %>% 
     summarize(
       avg_count = mean(counts, na.rm = TRUE)
     ) %>%
     ungroup() %>% 
     group_by(feature) %>% 
       summarize(
       mean_count = mean(avg_count, na.rm = TRUE),
       sd_count = sd(avg_count, na.rm = TRUE),
       cv = sd_count / mean_count
     ) %>%
     arrange(cv) %>% 
     left_join(MAG_annotation)
   
}
```

```{r hkg_selection}
hkg_vector <- rownames(dds) %in% "CLCDCC_00215" 
dds_hkg <- DESeq2::estimateSizeFactors(dds, controlGenes = hkg_vector)

## Convert back again to tidybulk experimental object to ensure downstream compatibility
hkg_counts <- counts(dds_hkg, normalized = T) %>% round() %>% as_tibble(rownames = "feature") %>% 
  pivot_longer(cols = sample_info$sample_ID, names_to = "sample", values_to = "hkg_counts") %>%  
  right_join(counts %>% as_tibble(), by = c("feature", "sample")) %>% 
  dplyr::select(-counts) %>% 
  rename(counts = hkg_counts) %>% 
  as_SummarizedExperiment(.abundance = counts,
                          .sample = sample,
                          .transcript = feature)
```

```{r hkg_combat}
#| label: tbl-hkg_genes_combat
MAG_annotation %>% 
  filter(gene_symbol %in% housekeeping_genes) %>% 
  left_join(combat_counts %>% as_tibble(), by = "feature") %>% 
  group_by(feature, sample) %>% 
  summarize(
    avg_count = mean(counts, na.rm = TRUE)
  ) %>%
  ungroup() %>% 
  group_by(feature) %>% 
    summarize(
    mean_count = mean(avg_count, na.rm = TRUE),
    sd_count = sd(avg_count, na.rm = TRUE),
    cv = sd_count / mean_count
  ) %>%
  arrange(cv) %>% 
  left_join(MAG_annotation) %>% 
  select(gene_symbol, mean = mean_count, sd = sd_count, cv, `function` = gene_function) %>% 
  knitr::kable(digits = 2, caption = "List of genes that could be used for houskeeping gene based normalisation. The mean and standard deviation (sd) are based on the raw read counts and the coefficient of variation (cv) represents the variation of these genes accross all samples and replicates. Lower cv represents less variation. Genes with the least variation should used as references in housekeeping gene normalisation.")
```

#### Inspect housekeeping genes within each replicate
```{r hkg_replicates, message=F, warning=F}
housekeeping_replicates <- list()

for (replicate_id in unique(sample_info$replicate)) {
    housekeeping_replicates[[replicate_id]] <-  
     MAG_annotation %>%  
     filter(gene_symbol %in% housekeeping_genes) %>% 
     left_join(combat_counts %>% as_tibble(), by = "feature") %>% 
     filter(replicate == replicate_id) %>% 
     group_by(feature, sample) %>% 
     summarize(
       avg_count = mean(counts, na.rm = TRUE)
     ) %>%
     ungroup() %>% 
     group_by(feature) %>% 
       summarize(
       mean_count = mean(avg_count, na.rm = TRUE),
       sd_count = sd(avg_count, na.rm = TRUE),
       cv = sd_count / mean_count
     ) %>%
     arrange(cv) %>% 
     left_join(MAG_annotation)
}
```
```{r}
hkg_vector <- rownames(dds) %in% "CLCDCC_00215"
dds_hkg <- DESeq2::estimateSizeFactors(dds, controlGenes = hkg_vector)

## Convert back again to tidybulk experimental object to ensure downstream compatibility
hkg_combat_counts <- counts(dds_hkg, normalized = T) %>% round() %>% as_tibble(rownames = "feature") %>% 
  pivot_longer(cols = sample_info$sample_ID, names_to = "sample", values_to = "hkg_counts") %>%  
  right_join(counts %>% as_tibble(), by = c("feature", "sample")) %>% 
  dplyr::select(-counts) %>% 
  rename(counts = hkg_counts) %>% 
  as_SummarizedExperiment(.abundance = counts,
                          .sample = sample,
                          .transcript = feature)
```
In general, there is a high variability for the all the housekeeping genes (HKG)
that we evaluated, either based on condition (@fig-hkg_expression_conditions)
and replicate (@fig-hkg_expression_replicates) -level expression, which may not
make them suitable to be used as a reference for scaling. @tbl-hkg_genes_count
summarises the variability of HKGs across all samples. However, if we must make
a choice, 'dnaK', would be selected as the reference HKG as it shows the lowest
coefficient of variation (cv). Equivalent evaluation was conducted for
ComBat-seq normalised data (@tbl-hkg_genes_combat) reveals that the ComBat batch
correction procedure significantly reduced the variability between housekeeping
genes. Similarly, 'dnaK' once again appeared as the least variable genes. Based
on this, the normalisation of housekeeping genes for both raw counts and
ComBat-seq normalised data will use 'dnaK' as the HKG for scaling.

## Evaluation of data
```{r initiate_plot_lists}
# Initiate lists
## List of PCA plots
p.pca <- list() 

## List of MDS plots
p.mds <- list()

## List of boxplots
p.bp <- list()

## List of density plots
p.dp <- list()

## List of density plots
p.hm <- list()
```
```{r pca_raw_counts}
p.pca[[1]] <- 
  counts %>%
  reduce_dimensions(method = "PCA") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = PC1, y = PC2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r mds_raw_counts}
p.mds[[1]] <- 
  counts %>%
  reduce_dimensions(method = "MDS") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = Dim1, y = Dim2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r boxplot_raw_counts}
p.bp[[1]] <-  
  counts %>% as_tibble() %>%  
  ggplot(aes(x = .sample, y = log(counts), fill = as.character(replicate))) +
  geom_boxplot() 
```
```{r density_raw_counts}
p.dp[[1]] <-   
  counts %>% as_tibble() %>%  
  ggplot(aes(x=counts, color=as.character(.sample))) + 
  geom_density() +
  scale_x_log10() + 
  theme_minimal()
```

```{r heatmap_raw_counts}
p.hm[[1]] <- 
  counts %>% 
  keep_abundant(minimum_counts = 1) %>% 
  
  # extract 100 most variable genes
  keep_variable(.abundance = counts, top = 100) %>%
  as_tibble() %>%
  mutate(replicate = as.character(replicate), 
         lane = as.character(lane)) %>% 
  
  # create heatmap
  heatmap(
    .column = sample,
    .row = feature,
    .value = counts,
    transform = log1p,
    name = "counts"
  ) %>%
  add_tile(condition) %>%
  add_tile(replicate) %>% 
  add_tile(lane)
```

```{r pca_combat}
p.pca[[2]] <- 
  combat_counts %>%
  reduce_dimensions(method = "PCA") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = PC1, y = PC2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```

```{r mds_combat}
p.mds[[2]] <-  
  combat_counts %>%
  reduce_dimensions(method = "MDS") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = Dim1, y = Dim2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```

```{r boxplot_combat}
p.bp[[2]] <- 
  combat_counts %>% as_tibble() %>% 
  ggplot(aes(x = sample, y = log(counts), fill = as.character(replicate))) + 
  geom_boxplot() 
```
```{r density_plot_combat}
p.dp[[2]] <- 
  combat_counts %>% as_tibble() %>%  
  ggplot(aes(x=counts, color=as.character(.sample))) +
  geom_density() +
  scale_x_log10() +
  theme_minimal()
```
```{r heatmap_combat}
p.hm[[2]] <- 
  combat_counts %>% 
  keep_abundant(minimum_counts = 1) %>% 
  
  # extract 100 most variable genes
  keep_variable(.abundance = counts, top = 100) %>%
  as_tibble() %>%
  mutate(replicate = as.character(replicate), 
         lane = as.character(lane)) %>% 
  
  # create heatmap
  heatmap(
    .column = sample,
    .row = feature,
    .value = counts,
    transform = log1p,
    name = "combat"
  ) %>%
  add_tile(condition) %>%
  add_tile(replicate) %>% 
  add_tile(lane)
```

```{r pca_hkg}
p.pca[[3]] <- 
  hkg_counts %>%
  reduce_dimensions(method = "PCA") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = PC1, y = PC2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r mds_hkg}
p.mds[[3]] <- 
  hkg_counts %>%
  reduce_dimensions(method = "MDS") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = Dim1, y = Dim2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r boxplot_hkg}
p.bp[[3]] <- 
  hkg_counts %>% as_tibble() %>%   
  ggplot(aes(x = .sample, y = log(counts), fill = as.character(replicate))) +
  geom_boxplot() 
```
```{r density_plot_hkg}
p.dp[[3]] <-  
  hkg_counts %>% as_tibble() %>%  
  ggplot(aes(x=counts, color=as.character(.sample))) +
  geom_density() + 
  scale_x_log10() + 
  theme_minimal()
```
```{r heatmap_hkg}
p.hm[[3]] <- 
  hkg_counts %>% 
  keep_abundant(minimum_counts = 1) %>% 
  
  # extract 100 most variable genes
  keep_variable(.abundance = counts, top = 100) %>%
  as_tibble() %>%
  mutate(replicate = as.character(replicate), 
         lane = as.character(lane)) %>% 
  
  # create heatmap
  heatmap(
    .column = sample,
    .row = feature,
    .value = counts,
    transform = log1p
  ) %>%
  add_tile(condition) %>%
  add_tile(replicate) %>% 
  add_tile(lane)
```
```{r pca_combat_hkg}
p.pca[[4]] <- 
  hkg_combat_counts %>%
  reduce_dimensions(method = "PCA") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = PC1, y = PC2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r mds_combat_hkg}
p.mds[[4]] <- 
  hkg_combat_counts %>%
  reduce_dimensions(method = "MDS") %>% 
  pivot_sample() %>% as_tibble() %>% 
  ggplot(aes(x = Dim1, y = Dim2, colour = as.character(replicate), shape = phase)) +
  geom_point() +
  geom_text_repel(aes(label = .sample), show.legend = FALSE) +
  theme_minimal()
```
```{r boxplot_combat_hkg}
p.bp[[4]] <- 
  hkg_combat_counts %>% as_tibble() %>%  
  ggplot(aes(x = .sample, y = log(counts), fill = as.character(replicate))) +
  geom_boxplot() 
```
```{r density_plot_combat_hkg}
p.dp[[4]] <- 
  hkg_combat_counts %>% as_tibble() %>%  
  ggplot(aes(x=counts, color=as.character(.sample))) + 
  geom_density() +
  scale_x_log10() + 
  theme_minimal()
```
```{r heatmap_combat_hkg}
p.hm[[4]] <- 
  hkg_combat_counts %>% 
  keep_abundant(minimum_counts = 1) %>% 
  
  # extract 100 most variable genes
  keep_variable(.abundance = counts, top = 100) %>%
  as_tibble() %>%
  mutate(replicate = as.character(replicate), 
         lane = as.character(lane)) %>% 
  
  # create heatmap
  heatmap(
    .column = sample,
    .row = feature,
    .value = counts,
    transform = log1p
  ) %>%
  add_tile(condition) %>%
  add_tile(replicate) %>% 
  add_tile(lane)
```

```{r plot_pca}
#| label: fig-pca
#| fig-cap: "Visualisation of principal component analysis (PCA) dimensionality reduction of unnormalised raw counts and various normalised/scaled counts. HKG - housekeeping genes based scaling." 
#| fig-subcap:
#|   - "Raw counts"
#|   - "ComBat-seq" 
#|   - "HKG" 
#|   - "ComBat-seq + HKG" 
#| layout-ncol: 2
p.pca[[1]] 
p.pca[[2]] 
p.pca[[3]] 
p.pca[[4]] 
```
```{r plot_mds}
#| label: fig-mds
#| fig-cap: "Visualisation of multi-dimensional scaling (MDS) dimensionality reduction of unnormalised raw counts and various normalised/scaled counts. HKG - housekeeping genes based scaling." 
#| fig-subcap:
#|   - "Raw counts"
#|   - "ComBat-seq" 
#|   - "HKG" 
#|   - "ComBat-seq + HKG" 
#| layout-ncol: 2
p.mds[[1]] 
p.mds[[2]] 
p.mds[[3]] 
p.mds[[4]] 
```
```{r generate_boxplot}
for (i in 1:length(p.bp)){
  if (i <= 3){
    p.bp[[i]] <- 
      p.bp[[i]] +  
      theme( 
        axis.text.x = element_blank(), 
        axis.title.x = element_blank()
      ) 
  } else {
   p.bp[[i]] <- p.bp[[i]] + 
     theme(
       axis.text.x = element_text(angle = 90)
       )
  }
}
```
```{r plot_boxplots}
#| label: fig-boxplot
#| fig-cap: "Boxplots of unnormalised raw counts and various normalised/scaled counts. HKG - housekeeping genes based scaling." 
#| fig-subcap:
#|   - "Raw counts"
#|   - "ComBat-seq" 
#|   - "HKG" 
#|   - "ComBat-seq + HKG" 
#| layout-ncol: 1
#| fig-height: 2

p.bp[[1]] 
p.bp[[2]] 
p.bp[[3]] 
p.bp[[4]] 
```

```{r plot_density_plots}
#| label: fig-density_plot
#| fig-cap: "Density plots of unnormalised raw counts and various normalised/scaled counts. HKG - housekeeping genes based scaling." 
#| fig-subcap:
#|   - "Raw counts"
#|   - "ComBat-seq" 
#|   - "HKG" 
#|   - "ComBat-seq + HKG" 
#| layout-ncol: 2
p.dp[[1]] 
p.dp[[2]] 
p.dp[[3]] 
p.dp[[4]] 
```

```{r}
#| label: fig-heatmap
#| fig-cap: "Heatmap of topm variable genes in the unnormalised raw counts and various normalised/scaled counts. HKG - housekeeping genes based scaling." 
#| fig-subcap:
#|   - "Raw counts"
#|   - "ComBat-seq" 
#|   - "HKG" 
#|   - "ComBat-seq + HKG" 
#| layout-ncol: 2
#| fig-height: 8
p.hm[[1]] 
p.hm[[2]] 
p.hm[[3]] 
p.hm[[4]] 
```

Dimensionality reduction using principal component analysis (PCA; @fig-pca) and
multi-dimensional scaling (MDS; @fig-mds) show that there is no clustering
solely based on replicate number in the raw counts and in the scaled/normalised
data. It can be observed that the housekeeping gene (HKG) -based scaling creates
the most effect when applied to the raw and ComBat-seq normalised counts. It
must be noted that this pattern is *not* observed when performing the same
analysis of the entire transcriptome (i.e. not just isolating Geobacter
transcripts).

The boxplots (@fig-boxplot) display the effect of the various normalisation and
scaling procedures applied to the raw counts. The density plots
(@fig-density_plot) indicates that the scaling using HKG drastically changes the
distribution of the data, such that the multi-modal nature of the data is
further amplified.

## Differential expression analysis
Differential expression (DE) analysis is separated into initial and backflush flow to
delineate the differentially expressed genes stemming from each part of the
experiment. Transcripts that have a count of at least one read in at least 70%
of the samples are considered sufficiently abundant for downstream DE analysis.
The model applied for DE tests is `~condition + replicate + lane`. Specifically,
we compute the contrast between the true biological conditions of interest (i.e.
treatment vs control) while "removing" technical differences `replicate` and
`lane` from the model, also known as (modelling out). DE is performed using four
different methods: 
1. EdgeR using quasi-likelihood tests (QLT) 
2. EdgeR using likelihood ratio (LR) tests 
3. limma-voom
4. DESeq2

Each of these methods are applied to the raw counts and the three different
normalisation/scaling methods, i.e. i) ComBat-seq, ii) HKG and iii) ComBat-seq + HKG.
This results in a total of 16 different DE results. 

The DE results were consolidated based on the following criteria: 
1. Identified as differentially expressed in at least one combination of data
normalisation (e.g. raw, ComBat, HKG, etc.) and DE analysis method (i.e.
EdgeR-QLT, DESeq2). This results in up to a total of 16 combinations
2. Count the number of DE tests that were performed on the transcript out of the possible 16, i.e. non-NA values
3. Count the number of DE tests in which the p-value \leq 0.05 from those identified in 2. (above)
4. Compute a composite p-value using Fisher and Stouffer test based on the p-values from all the different DE analysis (and their combinations, thereof)
5. Correct the composite p-values using multiple methods (i.e. Benjamini-Hochberg, Benjamini-Yukateli, Bonferroni, false discovery rate; FDR)

A transcript that is significantly differentially expressed based on the following criteria:
1. Significant (i.e. p-value \leq 0.05) in at least 50% of the DE analysis which contained p-values (i.e. non-NA)
2. Composite Fisher test FDR \leq 0.05
3. Consistent expression directionality (i.e. up/down) accross all the different tests (i.e. log fold-change)
4. Absolute fold-chage of 2

@fig-volcano shows an overview of the expressed genes, while @fig-topgenes
visualises the expression of the most significant genes.


```{r define_expression_object_list}
expr_list <- list("raw" = counts, "combat" = combat_counts, "hkg" = hkg_counts, "combat_hkg" = hkg_combat_counts)
```
```{r function_de}
## Function: Perform all DE analysis methods on given tables/normalisations including different phases
compute_DE_genes <- function(expr_list, phase_value = "normal"){ 
  
  for (i in 1:length(expr_list)){ 
    expr_obj <-
      expr_list[[i]] %>% 
      filter(phase == {{ phase_value }}) %>% 
      keep_abundant(minimum_counts = 1) 
    
    expr_source <- names(expr_list)[i]
    
    tmp_de_res <-  
     
       expr_obj %>% 
      # edgeR QLT
      test_differential_abundance(
        ~ condition + replicate + lane,
        method = "edgeR_quasi_likelihood",
        prefix = paste0(expr_source, "_", "edgerQLT_")
      ) %>%
    
      # edgeR LRT
      test_differential_abundance(
        ~ condition + replicate + lane,
        method = "edgeR_likelihood_ratio",
        prefix = paste0(expr_source, "_", "edgerLR_")
      ) %>%
    
      # limma-voom
      test_differential_abundance(
        ~ condition + replicate + lane,
        method = "limma_voom",
        prefix = paste0(expr_source, "_", "voom_")
      ) 
    
    ## DESeq2
    tmp_de_res <-  
      expr_obj %>% 
      as_tibble() %>% 
      mutate(counts = round(counts)) %>% 
      as_SummarizedExperiment(.sample = sample, 
                              .abundance = counts,
                              .transcript = feature) %>% 
      test_differential_abundance(
        ~ condition + replicate + lane,
        method = "DESeq2",
        prefix = paste0(expr_source, "_", "DESeq2_")
        ) %>% 
      as_tibble() %>% 
      select(contains("DESeq2_")) %>% 
      bind_cols(tmp_de_res %>% as_tibble(), .) %>%  
      as_SummarizedExperiment(.sample = sample,
                              .abundance = counts,
                              .transcript = feature)
     
    ## Now join the tables 
    if (i == 1){
      de_res <- 
        tmp_de_res %>% 
        as_tibble() %>% 
        distinct() %>%   
        select(-c(".feature",   
                  ".sample", 
                  "counts", 
                  "sample", 
                  "SampleName", 
                  "condition", 
                  "phase", 
                  "replicate", 
                  "lane", 
                  "Run", 
                  ".abundant")) %>%  
        distinct()
    } else {
      de_res <-  
        full_join(de_res, 
                  tmp_de_res %>% as_tibble() %>%   
                    select(-c(".feature",   
                              ".sample", 
                              "counts", 
                              "sample", 
                              "SampleName", 
                              "condition", 
                              "phase", 
                              "replicate", 
                              "lane", 
                              "Run", 
                              ".abundant")) %>%  
                    distinct(),  
                  by = c("feature", "avgLength")) %>%   
        distinct() 
      } 
  } 
  return(de_res)
  }
```

```{r function_expression_consistency}
# Function: Define consistency of directionality
all_same_direction <- function(values) {
  non_na_values <- na.omit(values)
  all(non_na_values > 0) | all(non_na_values < 0)
}
```

```{r function_compute_compostite_scores}
## Function: Compute composite DE scores such as proportion of significant p-values and composite p-values and adjusted p-values
compute_composite_DE_results <- function(de_res){ 
  # List p-value columns
  pvalue_cols <- 
    de_res %>% 
    select(contains("_PValue"), contains("_P.Value"), contains("_pvalue")) %>% 
    colnames()
  
  # List fold-change columns
  fc_cols <- 
    de_res %>% 
    select(contains("Fold"), contains("FC")) %>%  
    select(!contains("DESeq2_lfcSE")) %>% 
    colnames()
  
  comp_de_res <-  
    de_res %>%  
    rowwise() %>%  
    mutate(significant_count = sum(across(all_of(pvalue_cols),  
                                          ~ifelse(is.na(.), NA, . < 0.05)), na.rm = TRUE),  
           non_na_count = sum(!is.na(across(all_of(pvalue_cols))))) %>%  
    ungroup() %>%  
    mutate(significant_proportion = significant_count/non_na_count) %>%  
    rowwise() %>%  
    mutate(consistent_direction = all_same_direction(across(all_of(fc_cols)))) %>%
    ungroup() %>% 
    mutate(    
      composite_p_val_fisher = pmap_dbl(  
        select(., matches("_PValue|P\\.Value|_pvalue")),
        .f = function(...) { 
          args <- list(...)
          p_values <- na.omit(unlist(args))
          if (length(p_values) == 0) {
            return(NA_real_)
          }
          sumlog(p_values)$p
        }
        ),
      composite_p_val_stouffer = pmap_dbl( 
        select(., matches("_PValue|P\\.Value|_pvalue")),
        .f = function(...) {
          args <- list(...)
          p_values <- na.omit(unlist(args))
          if (length(p_values) == 0) {
            return(NA_real_)
          }
          metap::sumz(p_values)$p
        }
        )   
    ) %>%   
    mutate( 
      composite_p_val_fisher_BH = p.adjust(composite_p_val_fisher, method = "BH"),
      composite_p_val_stouffer_BH = p.adjust(composite_p_val_stouffer, method = "BH"),
      composite_p_val_fisher_BY = p.adjust(composite_p_val_fisher, method = "BY"),
      composite_p_val_stouffer_BY = p.adjust(composite_p_val_stouffer, method = "BY"),
      composite_p_val_fisher_bonferroni = p.adjust(composite_p_val_fisher, method = "bonferroni"),
      composite_p_val_stouffer_bonferroni = p.adjust(composite_p_val_stouffer, method = "bonferroni"),
      composite_p_val_fisher_fdr = p.adjust(composite_p_val_fisher, method = "fdr"),
      composite_p_val_stouffer_fdr = p.adjust(composite_p_val_stouffer, method = "fdr") 
      )
}
```

```{r}
de_norm <- compute_DE_genes(expr_list = expr_list, phase = "normal")
comp_de_norm <- compute_composite_DE_results(de_norm)
```
```{r}
de_bflush <- compute_DE_genes(expr_list = expr_list, phase = "backflush")
comp_de_bflush <- compute_composite_DE_results(de_bflush)
```
```{r write_full_table, eval = F}
write_tsv(comp_de_norm, "/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/differential_expression_results_initial.tsv")
write_tsv(comp_de_bflush, "/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/differential_expression_results_backflush.tsv")

```
```{r write_topgenes_table, eval = F}
comp_de_norm %>% 
  filter(composite_p_val_fisher_fdr <= 0.05 & 
           significant_proportion > 0.5 & 
           combat_DESeq2_log2FoldChange >= abs(log2(2))) %>% 
  select(feature, composite_p_val_fisher, composite_p_val_fisher_fdr, significant_proportion, raw_edgerQLT_logFC) %>% 
  left_join(MAG_annotation, by = "feature") %>% 
  bind_cols(phase = "initial") %>% 
  select(feature, phase, everything()) %>% 
  write_tsv("/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/differential_expression_results-2FC_0.05FDR_withAnnotation.tsv")
  
comp_de_bflush %>% 
  filter(composite_p_val_fisher_fdr <= 0.05 & 
           significant_proportion > 0.5 & 
           combat_DESeq2_log2FoldChange >= abs(log2(2))) %>% 
  select(feature, composite_p_val_fisher, composite_p_val_fisher_fdr, significant_proportion, raw_edgerQLT_logFC) %>% 
  left_join(MAG_annotation, by = "feature") %>% 
  bind_cols(phase = "backflush") %>% 
  select(feature, phase, everything()) %>% 
  write_tsv("/Users/shaman.narayanasamy/Work/Data/KAUST/membrane_cleaning/differential_expression_results-2FC_0.05FDR_withAnnotation.tsv", append = T)
```

```{r get_top_genes}
topgenes_norm <- 
  comp_de_norm %>% 
  arrange(composite_p_val_fisher) %>%
  head(10) %>%
  pull(feature) 

topgenes_bflush <- 
  comp_de_bflush %>% 
  arrange(composite_p_val_fisher) %>%
  head(10) %>%
  pull(feature) 
```

```{r volcano_plot}
#| label: fig-volcano
#| fig-cap: "Volcano plot of differentially expressed genes. P-values are based on the composite Fischer p-value and fold-changes are based on raw counts edgeR quasi-likelihood test computation." 
#| fig-subcap:
#|   - "Initial flow"
#|   - "Backflush" 
#| layout-ncol: 1
counts %>%  
  full_join(comp_de_norm %>% select(feature, contains("raw_"), composite_p_val_fisher, composite_p_val_fisher_fdr), by = "feature") %>% 
  mutate(log10_composite_p_val_fisher = log10(composite_p_val_fisher)) %>% 
  pivot_transcript(.transcript = .feature) %>%
  filter(!is.na(raw_edgerQLT_logFC)) %>% 
  mutate(significant = composite_p_val_fisher_fdr <= 0.05 & abs(raw_edgerQLT_logFC) >= log2(2)) %>% 
  mutate(symbol = ifelse(.feature %in% topgenes_norm, as.character(.feature), "")) %>% 
  ggplot(aes(x = raw_edgerQLT_logFC, y = -log10_composite_p_val_fisher, label = symbol)) +
  geom_point(aes(color = significant, size = significant)) +
  geom_text_repel() +
  theme_minimal() +
  scale_color_manual(values = c("black", "#e11f28")) +
  scale_size_discrete(range = c(1, 2))

counts %>%  
  full_join(comp_de_bflush %>% select(feature, contains("raw_"), composite_p_val_fisher, composite_p_val_fisher_fdr), by = "feature") %>% 
  mutate(log10_composite_p_val_fisher = log10(composite_p_val_fisher)) %>% 
  pivot_transcript(.transcript = .feature) %>%
  filter(!is.na(raw_edgerQLT_logFC)) %>% 
  mutate(significant = composite_p_val_fisher_fdr <= 0.05 & abs(raw_edgerQLT_logFC) >= log2(2)) %>% 
  mutate(symbol = ifelse(.feature %in% topgenes_norm, as.character(.feature), "")) %>% 
  ggplot(aes(x = raw_edgerQLT_logFC, y = -log10_composite_p_val_fisher, label = symbol)) +
  geom_point(aes(color = significant, size = significant)) +
  geom_text_repel() +
  theme_minimal() +
  scale_color_manual(values = c("black", "#e11f28")) +
  scale_size_discrete(range = c(1, 2))

```


```{r visualise_stripchart}
#| label: fig-topgenes
#| fig-cap: "Stripchart of the most significantly expressed genes." 
#| fig-subcap:
#|   - "Initial flow"
#|   - "Backflush" 
#| layout-ncol: 1

counts %>%

  # extract counts for top differentially expressed genes
  filter(feature %in% topgenes_norm) %>%

  # make faceted stripchart
  ggplot(aes(x = condition, y = counts + 1, fill = condition, group = condition)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~feature) +
  scale_y_log10() +
  theme_minimal()

counts %>%

  # extract counts for top differentially expressed genes
  filter(feature %in% topgenes_bflush) %>%

  # make faceted stripchart
  ggplot(aes(x = condition, y = counts + 1, fill = condition, group = condition)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~feature) +
  scale_y_log10() +
  theme_minimal()
```